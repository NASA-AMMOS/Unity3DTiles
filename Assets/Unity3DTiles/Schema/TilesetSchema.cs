//----------------------
// <auto-generated>
//     Generated using the NJsonSchema v9.10.13.0 (Newtonsoft.Json v9.0.0.0) (http://NJsonSchema.org)
// </auto-generated>
//----------------------

using System.Collections.Generic;

namespace Unity3DTiles.Schema
{
#pragma warning disable // Disable all warnings

    /// <summary>Metadata about the entire tileset.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Asset
    {
        /// <summary>The 3D Tiles version.  The version defines the JSON schema for tileset.json and the base set of tile formats.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public string Version { get; set; }

        /// <summary>Application-specific version of this tileset, e.g., for when an existing tileset is updated.</summary>
        [Newtonsoft.Json.JsonProperty("tilesetVersion", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TilesetVersion { get; set; }

        /// <summary>Specifies the up-axis of glTF models.</summary>
        [Newtonsoft.Json.JsonProperty("gltfUpAxis", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AssetGltfUpAxis GltfUpAxis = AssetGltfUpAxis.Y;

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Asset FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Asset>(data);
        }
    }

    /// <summary>A dictionary object of metadata about per-feature properties.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Properties
    {
        /// <summary>The maximum value of this property of all the features in the tileset.</summary>
        [Newtonsoft.Json.JsonProperty("maximum", Required = Newtonsoft.Json.Required.Always)]
        public double Maximum { get; set; }

        /// <summary>The minimum value of this property of all the features in the tileset.</summary>
        [Newtonsoft.Json.JsonProperty("minimum", Required = Newtonsoft.Json.Required.Always)]
        public double Minimum { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Properties FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Properties>(data);
        }
    }

    /// <summary>A bounding volume that encloses a tile or its contents.  Exactly one property is required.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class BoundingVolume
    {

        /// <summary>An array of 12 numbers that define an oriented bounding box.  The first three elements define the x, y, and z values for the center of the box.  The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.  The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.  The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.</summary>
        [Newtonsoft.Json.JsonProperty("box", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<double> Box = new List<double>();

        /// <summary>An array of six numbers that define a bounding geographic region in WGS84 / EPSG:4326 coordinates with the order [west, south, east, north, minimum height, maximum height]. Longitudes and latitudes are in radians, and heights are in meters above (or below) the WGS84 ellipsoid.</summary>
        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<double> Region = new List<double>();

        /// <summary>An array of four numbers that define a bounding sphere.  The first three elements define the x, y, and z values for the center of the sphere.  The last element (with index 3) defines the radius in meters.</summary>
        [Newtonsoft.Json.JsonProperty("sphere", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<double> Sphere = new List<double>();

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static BoundingVolume FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<BoundingVolume>(data);
        }
    }

    /// <summary>Metadata about the tile's content and a link to the content.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class TileContent
    {
        /// <summary>An optional bounding volume that tightly encloses just the tile's contents. This is used for replacement refinement; tile.boundingVolume provides spatial coherence and tile.content.boundingVolume enables tight view frustum culling. When this is omitted, tile.boundingVolume is used.</summary>
        [Newtonsoft.Json.JsonProperty("boundingVolume", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BoundingVolume BoundingVolume = new BoundingVolume();

        /// <summary>A string that points to the tile's contents with an absolute or relative url. When the url is relative, it is relative to the referring tileset.json. The file extension of content.url defines the tile format. The core 3D Tiles spec supports the following tile formats: Batched 3D Model (*.b3dm), Instanced 3D Model (*.i3dm), Composite (*.cmpt), and 3D Tiles TileSet (*.json)</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        public string Url { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static TileContent FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TileContent>(data);
        }
    }

    /// <summary>A tile in a 3D Tiles tileset.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Tile
    {
        /// <summary>The bounding volume that encloses the tile.</summary>
        [Newtonsoft.Json.JsonProperty("boundingVolume", Required = Newtonsoft.Json.Required.Always)]
        public BoundingVolume BoundingVolume  = new BoundingVolume();

        /// <summary>Optional bounding volume that defines the volume that the viewer must be inside of before the tile's content will be requested and before the tile will be refined based on geometricError.</summary>
        [Newtonsoft.Json.JsonProperty("viewerRequestVolume", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BoundingVolume ViewerRequestVolume { get; set; }

        /// <summary>Defines when a tile's content expires and should be re-requested. If both date and duration are present, the sooner value is used.</summary>
        [Newtonsoft.Json.JsonProperty("expire", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Expire Expire = new Expire();

        /// <summary>The error, in meters, introduced if this tile is rendered and its children are not. At runtime, the geometric error is used to compute Screen-Space Error (SSE), i.e., the error measured in pixels.</summary>
        [Newtonsoft.Json.JsonProperty("geometricError", Required = Newtonsoft.Json.Required.Always)]
        public double GeometricError { get; set; }

        /// <summary>Specifies if additive or replacement refinement is used when traversing the tileset for rendering.  This property is required for the root tile of a tileset; it is optional for all other tiles.  The default is to inherit from the parent tile.</summary>
        [Newtonsoft.Json.JsonProperty("refine", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TileRefine? Refine { get; set; }

        /// <summary>A floating-point 4x4 affine transformation matrix, stored in column-major order, that transforms the tile's content, i.e., its features and content.boundingVolume, and boundingVolume and viewerRequestVolume from the tile's local coordinate system to the parent tile's coordinate system, or tileset's coordinate system in the case of the root tile.  transform does not apply to geometricError nor does it apply any volume property when the volume is a region, which is defined in WGS84 / EPSG:4326 coordinates.</summary>
        [Newtonsoft.Json.JsonProperty("transform", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<double> Transform = new List<double>();

        /// <summary>Metadata about the tile's content and a link to the content. When this is omitted the tile is just used for culling. This is required for leaf tiles.</summary>
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TileContent Content  = null;

        /// <summary>An array of objects that define child tiles. Each child tile has a box fully enclosed by its parent tile's box and, generally, a geometricError less than its parent tile's geometricError. For leaf tiles, the length of this array is zero, and children may not be defined.</summary>
        [Newtonsoft.Json.JsonProperty("children", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<Tile> Children = new List<Tile>();

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Tile FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Tile>(data);
        }
    }

    /// <summary>A 3D Tiles tileset.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Tileset
    {
        [Newtonsoft.Json.JsonProperty("asset", Required = Newtonsoft.Json.Required.Always)]
        public Asset Asset = new Asset();

        /// <summary>A dictionary object of metadata about per-feature properties.</summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Dictionary<string, object> Properties { get; set; }

        /// <summary>The error, in meters, introduced if this tileset is not rendered. At runtime, the geometric error is used to compute Screen-Space Error (SSE), i.e., the error measured in pixels.</summary>
        [Newtonsoft.Json.JsonProperty("geometricError", Required = Newtonsoft.Json.Required.Always)]
        public double GeometricError { get; set; }

        /// <summary>The root node.</summary>
        [Newtonsoft.Json.JsonProperty("root", Required = Newtonsoft.Json.Required.Always)]
        public Tile Root = new Tile();

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Tileset FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Tileset>(data);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum AssetGltfUpAxis
    {
        [System.Runtime.Serialization.EnumMember(Value = "X")]
        X = 0,

        [System.Runtime.Serialization.EnumMember(Value = "Y")]
        Y = 1,

        [System.Runtime.Serialization.EnumMember(Value = "Z")]
        Z = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Expire
    {
        /// <summary>The ISO8601 representation of the date at which the tile's content expires.</summary>
        [Newtonsoft.Json.JsonProperty("date", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Date { get; set; }

        /// <summary>The number of seconds since the tile's content is loaded when the tile's content expires.</summary>
        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Duration { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Expire FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Expire>(data);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum TileRefine
    {
        [System.Runtime.Serialization.EnumMember(Value = "ADD")]
        ADD = 0,

        [System.Runtime.Serialization.EnumMember(Value = "REPLACE")]
        REPLACE = 1,

    }
}