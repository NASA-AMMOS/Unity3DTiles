//----------------------
// <auto-generated>
//     Generated using the NJsonSchema v9.10.13.0 (Newtonsoft.Json v9.0.0.0) (http://NJsonSchema.org)
// </auto-generated>
//----------------------

using System.Collections.Generic;

namespace Unity3DTiles.Schema
{
    #pragma warning disable // Disable all warnings

    /// <summary>Metadata about the entire tileset.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Asset 
    {
        /// <summary>The 3D Tiles version.  The version defines the JSON schema for the tileset JSON and the base set of tile formats.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public string Version { get; set; }
    
        /// <summary>Application-specific version of this tileset, e.g., for when an existing tileset is updated.</summary>
        [Newtonsoft.Json.JsonProperty("tilesetVersion", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TilesetVersion { get; set; }
    
        [Newtonsoft.Json.JsonProperty("extensions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.Dictionary<string, object> Extensions = new System.Collections.Generic.Dictionary<string, object>();
    
        [Newtonsoft.Json.JsonProperty("extras", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Extras { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
        
        public static Asset FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Asset>(data);
        }
    }
    
    /// <summary>A dictionary object of metadata about per-feature properties.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Properties 
    {
        /// <summary>The maximum value of this property of all the features in the tileset.</summary>
        [Newtonsoft.Json.JsonProperty("maximum", Required = Newtonsoft.Json.Required.Always)]
        public double Maximum { get; set; }
    
        /// <summary>The minimum value of this property of all the features in the tileset.</summary>
        [Newtonsoft.Json.JsonProperty("minimum", Required = Newtonsoft.Json.Required.Always)]
        public double Minimum { get; set; }
    
        [Newtonsoft.Json.JsonProperty("extensions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.Dictionary<string, object> Extensions = new System.Collections.Generic.Dictionary<string, object>();
    
        [Newtonsoft.Json.JsonProperty("extras", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Extras { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
        
        public static Properties FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Properties>(data);
        }
    }
    
    /// <summary>A bounding volume that encloses a tile or its content.  Exactly one `box`, `region`, or `sphere` property is required.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class BoundingVolume 
    {
        /// <summary>An array of 12 numbers that define an oriented bounding box.  The first three elements define the x, y, and z values for the center of the box.  The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.  The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.  The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.</summary>
        [Newtonsoft.Json.JsonProperty("box", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<double> Box = new List<double>();
    
        /// <summary>An array of six numbers that define a bounding geographic region in EPSG:4979 coordinates with the order [west, south, east, north, minimum height, maximum height]. Longitudes and latitudes are in radians, and heights are in meters above (or below) the WGS84 ellipsoid.</summary>
        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<double> Region = new List<double>();
    
        /// <summary>An array of four numbers that define a bounding sphere.  The first three elements define the x, y, and z values for the center of the sphere.  The last element (with index 3) defines the radius in meters.</summary>
        [Newtonsoft.Json.JsonProperty("sphere", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<double> Sphere = new List<double>();
    
        [Newtonsoft.Json.JsonProperty("extensions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.Dictionary<string, object> Extensions = new System.Collections.Generic.Dictionary<string, object>();
    
        [Newtonsoft.Json.JsonProperty("extras", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Extras { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
        
        public static BoundingVolume FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<BoundingVolume>(data);
        }
    }
    
    /// <summary>Metadata about the tile's content and a link to the content.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class TileContent 
    {
        /// <summary>An optional bounding volume that tightly encloses just the tile's content. tile.boundingVolume provides spatial coherence and tile.content.boundingVolume enables tight view frustum culling. When this is omitted, tile.boundingVolume is used.</summary>
        [Newtonsoft.Json.JsonProperty("boundingVolume", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BoundingVolume BoundingVolume = new BoundingVolume();
    
        /// <summary>A uri that points to the tile's content. When the uri is relative, it is relative to the referring tileset JSON file.</summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uri { get; set; }

        /// <summary>
        /// Property to support legacy format that used url instead of uri
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        /// <summary>
        /// Helper method to get uri or uri parameter for backwards compatability
        /// </summary>
        /// <returns></returns>
        public string GetUri()
        {
            if(Uri!= null)
            {
                return Uri;
            }
            return Url;
        }

        [Newtonsoft.Json.JsonProperty("extensions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.Dictionary<string, object> Extensions = new System.Collections.Generic.Dictionary<string, object>();
    
        [Newtonsoft.Json.JsonProperty("extras", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Extras { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
        
        public static TileContent FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TileContent>(data);
        }
    }
    
    /// <summary>A tile in a 3D Tiles tileset.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Tile 
    {
        /// <summary>The bounding volume that encloses the tile.</summary>
        [Newtonsoft.Json.JsonProperty("boundingVolume", Required = Newtonsoft.Json.Required.Always)]
        public BoundingVolume BoundingVolume = new BoundingVolume();
    
        /// <summary>Optional bounding volume that defines the volume the viewer must be inside of before the tile's content will be requested and before the tile will be refined based on geometricError.</summary>
        [Newtonsoft.Json.JsonProperty("viewerRequestVolume", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BoundingVolume ViewerRequestVolume = new BoundingVolume();
    
        /// <summary>The error, in meters, introduced if this tile is rendered and its children are not. At runtime, the geometric error is used to compute screen space error (SSE), i.e., the error measured in pixels.</summary>
        [Newtonsoft.Json.JsonProperty("geometricError", Required = Newtonsoft.Json.Required.Always)]
        public double GeometricError { get; set; }
    
        /// <summary>Specifies if additive or replacement refinement is used when traversing the tileset for rendering.  This property is required for the root tile of a tileset; it is optional for all other tiles.  The default is to inherit from the parent tile.</summary>
        [Newtonsoft.Json.JsonProperty("refine", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TileRefine? Refine { get; set; }
    
        /// <summary>A floating-point 4x4 affine transformation matrix, stored in column-major order, that transforms the tile's content--i.e., its features as well as content.boundingVolume, boundingVolume, and viewerRequestVolume--from the tile's local coordinate system to the parent tile's coordinate system, or, in the case of a root tile, from the tile's local coordinate system to the tileset's coordinate system.  transform does not apply to geometricError, nor does it apply any volume property when the volume is a region, defined in EPSG:4979 coordinates.</summary>
        [Newtonsoft.Json.JsonProperty("transform", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<double> Transform = new List<double>();
    
        /// <summary>Metadata about the tile's content and a link to the content. When this is omitted the tile is just used for culling. This is required for leaf tiles.</summary>
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TileContent Content = null; //init to null to properly load no-content nodes
    
        /// <summary>An array of objects that define child tiles. Each child tile content is fully enclosed by its parent tile's bounding volume and, generally, has a geometricError less than its parent tile's geometricError. For leaf tiles, the length of this array is zero, and children may not be defined.</summary>
        [Newtonsoft.Json.JsonProperty("children", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<Tile> Children = new List<Tile>();
    
        [Newtonsoft.Json.JsonProperty("extensions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.Dictionary<string, object> Extensions = new System.Collections.Generic.Dictionary<string, object>();
    
        [Newtonsoft.Json.JsonProperty("extras", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Extras { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
        
        public static Tile FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Tile>(data);
        }
    }
    
    /// <summary>A 3D Tiles tileset.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Tileset 
    {
        [Newtonsoft.Json.JsonProperty("asset", Required = Newtonsoft.Json.Required.Always)]
        public Asset Asset = new Asset();
    
        /// <summary>A dictionary object of metadata about per-feature properties.</summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Dictionary<string, object> Properties { get; set; }
    
        /// <summary>The error, in meters, introduced if this tileset is not rendered. At runtime, the geometric error is used to compute screen space error (SSE), i.e., the error measured in pixels.</summary>
        [Newtonsoft.Json.JsonProperty("geometricError", Required = Newtonsoft.Json.Required.Always)]
        public double GeometricError { get; set; }
    
        /// <summary>The root tile.</summary>
        [Newtonsoft.Json.JsonProperty("root", Required = Newtonsoft.Json.Required.Always)]
        public Tile Root = new Tile();
    
        /// <summary>Names of 3D Tiles extensions used somewhere in this tileset.</summary>
        [Newtonsoft.Json.JsonProperty("extensionsUsed", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<string> ExtensionsUsed = new List<string>();
    
        /// <summary>Names of 3D Tiles extensions required to properly load this tileset.</summary>
        [Newtonsoft.Json.JsonProperty("extensionsRequired", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List<string> ExtensionsRequired = new List<string>();
    
        [Newtonsoft.Json.JsonProperty("extensions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.Dictionary<string, object> Extensions = new System.Collections.Generic.Dictionary<string, object>();
    
        [Newtonsoft.Json.JsonProperty("extras", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Extras { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
        
        public static Tileset FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Tileset>(data);
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.13.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum TileRefine
    {
        [System.Runtime.Serialization.EnumMember(Value = "ADD")]
        ADD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = "REPLACE")]
        REPLACE = 1,
    
    }   
}
